[자바스크립트 문법](ko.javascript.info)




# 노드의 정의

> Node는 서버인가?

- Node는 서버가 아닌 '런타임'이다.

  : 크롬 V8(자바스크립트 엔진)으로 빌드 된 **자바스크립트 런타임**




    > 런타임이란?
    
      : (쉽게 말하면) 실행기
    
        더이상 HTML에 종속되지 않고 실행될 수 있음

  



# 노드의 특성



## 이벤트

- 이벤트의 예: 클릭, 네트워크 요청, 타이머 등
- 이벤트 리스너: 이벤트를 등록하는 함수 (인터럽트 설정)
- 콜백 함수: 이벤트가 발생했을 때 실행될 함수



## 논블로킹 I/O

> 노드는 크게 "비동기면서 논블로킹", "동기면서 블로킹"으로 나뉜다.





## 프로세스 vs 스레드

- 프로세스: 운영체제에서 할당하는 작업의 단위, 프로세스 간 자원 공유 X

  > 프로그램 하나 실행하면, 프로세스는 하나만 뜸

- 스레드: 프로세스 내에서 실행되는 작업의 단위, 부모 프로세스 자원 공유

  > 프로세스 안에서 각자의 기능을 실행하는 단위. 마치 크롬내의 탭들과 유사


``` 노드는
Node.js의 스레드는 당연히 여러개(멀티)지만, 우리가 다룰 수 있는 스레드가 1개이기때문에, Node.js를 싱글스레드라 했음
```

> Node.js V14 부터, **멀티 스레드 사용 가능**
>
> 하지만, 아래의 이유로 **현업에서 멀티 스레드 기능은 이용할 일이 거의 없음**



### 멀티스레드

> 코딩이 상당히 어렵고, 처리 비용 증가

	### 싱글스레드

> 블로킹이 발생하는 경우, 나머지 작업은 모두 대기해야 함 == 비효율 발생

	### Node.js

​		> 주문을 다 받고, 번호표를 나눠주어 완료되면 알려주는 식

​			: **멀티스레드를 안하고**(어려우므로) 최대한 효율적으로 활용하기위해 Node.js를 이용



## Libuv

> 싱글스레드 비동기 I/O

 



## 서버로서의 노드

|            장점             |              단점               |
| :-------------------------: | :-----------------------------: |
|  컴퓨터 사용을 적게 사용함  |      적게 사용하는게 단점       |
| I/O 작업이 많은 서버로 적함 | CPU 작업이 많은 서버로는 부적함 |
|    자바스크립트를 사용함    |                                 |





## 노드의 작동방식

```
메모리 > 호출 스택(js) > 백그라운드(c++) > 테스크 큐(c++)  4단계로 구성
```

0. Anonymous 스택

1. 선언 된 함수를 메모리에 인스턴스

2. 

  1) setTimeOut()가 호출 스택에 올라가면, 백그라운드에 (타이머, 함수)가 올라감

  2) new Promise((resolve => {resolve('hi');})).then(console.log) 호출스택에 올라가면

  ​	then('실행이 다 되고나서 결과가 나왔을 때'라는 뜻)이 붙을때 백그라운드로 넘어감

3. 백그라운드에서는 명령어가 동시에 실행됨 (**멀티스레드**, c++로 구성)

4. 테스크 큐에 있는 명령들은 호출 스택이 다 **비워지고 나서야** 호출 스택에 올라감

   > 이때 Promise가 일반 호출 새치기함





# JavaScript 복습



## Const vs let

```
const는 뒤에 '='을 한번만 붙일 수 있음
```



## 함수호출

```
function_name() == function_name``
```



## Arrow Function

> Arrow Function은 Function을 대체할 수 없음
>
> - Function은 자신만의 **this**를 갖는데, Arrow Func.는 자신만의 this를 따로 **가지지 않음	**



- 객체 리턴의 경우

  ```javascript
  const obj = (x, y) => ({x, y})
  ```

  : 꼭 이렇게 소괄호를 쳐줘야, 엔진이 헷갈리지 않음



## 구조분해 할당

Before

```javascript
const example = {a: 123, b: {c: 135, d: 146}}
const a = example.a;
const d = example.b.d;
```

After

```javascript
const example = {a: 123, b: {c: 135, d: 146}}
const {a, b:{d}} = example;
console.log(a); // 123
console.log(d); // 146
```



Before

```javascript
arr = [1, 2, 3, 4, 5]
const x = arr[0]
const y = arr[1]
const z = arr[4]
```

After

```javascript
arr = [1, 2, 3, 4, 5]
const [x, y, , , z] = arr; // 자리가 똑같아야함!
```



**this가 있는 경우는 구조분해 할당이용 금지**





## 클래스

 